<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turning Patterns - Dual View</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #fff5f7;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #d4697a;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar */
        #sidebar {
            width: 260px;
            min-width: 260px;
            background: #fff0f3;
            border-right: 1px solid #f5c6d0;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 14px;
        }
        #sidebar h2 {
            font-size: 15px;
            color: #d4697a;
            margin-bottom: 4px;
        }
        #sidebar .subtitle {
            font-size: 10px;
            color: #e08090;
            margin-bottom: 12px;
            line-height: 1.4;
        }
        .section {
            margin-bottom: 14px;
        }
        .section-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #c85a6a;
            margin-bottom: 6px;
            border-bottom: 1px solid #f5c6d0;
            padding-bottom: 3px;
        }
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px;
        }
        .control-row label {
            font-size: 11px;
            color: #d4697a;
        }
        .control-row .val {
            font-size: 10px;
            color: #e06080;
            min-width: 30px;
            text-align: right;
        }
        input[type="range"] {
            width: 100%;
            accent-color: #e88a9a;
            margin-top: 1px;
            margin-bottom: 6px;
        }
        .btn-row {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            margin-bottom: 6px;
        }
        button {
            background: #ffe0e8;
            color: #c85a6a;
            border: 1px solid #f5c6d0;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.15s;
        }
        button:hover { background: #ffd0dc; border-color: #e88a9a; color: #b04050; }
        button.active { background: #e88a9a; border-color: #d4697a; color: #fff; }
        .preset-btn { flex: 1; min-width: 60px; }

        .feature-list {
            font-size: 10px;
            color: #d4697a;
            line-height: 1.5;
        }
        .feature-list li {
            margin-bottom: 3px;
            list-style: none;
            padding-left: 10px;
            position: relative;
        }
        .feature-list li::before {
            content: '•';
            color: #e88a9a;
            position: absolute;
            left: 0;
        }

        /* Dual canvas area */
        #main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        #canvas-container {
            flex: 1;
            display: flex;
            gap: 2px;
            background: #f5c6d0;
        }
        .canvas-wrap {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        .canvas-label {
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            font-weight: bold;
            color: #d4697a;
            background: rgba(255,240,243,0.9);
            padding: 3px 10px;
            border-radius: 10px;
            pointer-events: none;
            z-index: 10;
        }
        canvas {
            flex: 1;
            display: block;
            background: #ffffff;
            cursor: crosshair;
        }

        /* HUD */
        .hud {
            position: absolute;
            top: 35px;
            left: 8px;
            font-size: 10px;
            color: #c85a6a;
            line-height: 1.4;
            pointer-events: none;
            text-shadow: 0 0 4px rgba(255,255,255,0.8);
        }
        .hud span { color: #e06080; }

        /* Info bar */
        #info-bar {
            font-size: 10px;
            color: #d4697a;
            text-align: center;
            padding: 5px;
            background: #fff0f3;
            border-top: 1px solid #f5c6d0;
        }

        /* Color picker row */
        .color-row {
            display: flex;
            gap: 6px;
            align-items: center;
            margin-bottom: 6px;
        }
        .color-row label {
            font-size: 11px;
            color: #d4697a;
            flex: 1;
        }
        input[type="color"] {
            width: 35px;
            height: 20px;
            border: 1px solid #f5c6d0;
            border-radius: 4px;
            background: #ffe0e8;
            cursor: pointer;
        }

        /* Checkbox row */
        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
            font-size: 11px;
            color: #d4697a;
        }
        .checkbox-row input {
            accent-color: #e88a9a;
        }

        /* Sim selector */
        .sim-selector {
            display: flex;
            gap: 4px;
            margin-bottom: 10px;
        }
        .sim-selector button {
            flex: 1;
            padding: 6px;
        }
        .sim-selector button.selected {
            background: #d4697a;
            color: #fff;
            border-color: #c85a6a;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <h2>Turning Patterns</h2>
        <div class="subtitle">
            Two simulations running side by side with different parameters.
        </div>

        <div class="section">
            <div class="section-title">Control Simulation</div>
            <div class="sim-selector">
                <button id="selectLeft" class="selected">Left (Dragon)</button>
                <button id="selectRight">Right (Spiral)</button>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Pattern Parameters</div>
            <div class="control-row">
                <label>Turn Angle</label>
                <span class="val" id="angleVal">90°</span>
            </div>
            <input type="range" id="angle" min="1" max="180" value="90">

            <div class="control-row">
                <label>Step Length</label>
                <span class="val" id="stepVal">8</span>
            </div>
            <input type="range" id="step" min="1" max="40" value="8">

            <div class="control-row">
                <label>Line Width</label>
                <span class="val" id="widthVal">1.5</span>
            </div>
            <input type="range" id="lineWidth" min="0.5" max="6" step="0.5" value="1.5">
        </div>

        <div class="section">
            <div class="section-title">Animation</div>
            <div class="control-row">
                <label>Speed</label>
                <span class="val" id="speedVal">15</span>
            </div>
            <input type="range" id="speed" min="1" max="100" value="15">

            <div class="control-row">
                <label>Pink Variation</label>
                <span class="val" id="hueVal">0.3</span>
            </div>
            <input type="range" id="hue" min="0" max="10" step="0.1" value="0.3">

            <div class="control-row">
                <label>Saturation</label>
                <span class="val" id="satVal">60%</span>
            </div>
            <input type="range" id="sat" min="0" max="100" value="60">

            <div class="control-row">
                <label>Lightness</label>
                <span class="val" id="lightVal">65%</span>
            </div>
            <input type="range" id="light" min="20" max="80" value="65">
        </div>

        <div class="section">
            <div class="section-title">Visual Options</div>
            <div class="checkbox-row">
                <input type="checkbox" id="glowCheck">
                <label for="glowCheck">Glow Effect</label>
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="wrapCheck" checked>
                <label for="wrapCheck">Wrap Edges</label>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Presets (Selected Sim)</div>
            <div class="btn-row">
                <button class="preset-btn" id="presetDragon">Dragon</button>
                <button class="preset-btn" id="presetSpiral">Spiral</button>
                <button class="preset-btn" id="presetHex">Hexagon</button>
            </div>
            <div class="btn-row">
                <button class="preset-btn" id="presetTriangle">Triangle</button>
                <button class="preset-btn" id="presetChaos">Chaos</button>
                <button class="preset-btn" id="presetFine">Fine Web</button>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Controls</div>
            <div class="btn-row">
                <button id="pauseBtn" style="flex:1;">Pause All</button>
                <button id="resetBtn" style="flex:1;">Reset All</button>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Features</div>
            <ul class="feature-list">
                <li>Two simulations run simultaneously</li>
                <li>Click & drag to draw freehand</li>
                <li>Every other click toggles sparkles</li>
                <li>Shift+Click adds walker</li>
                <li>Scroll wheel adjusts angle</li>
                <li>Spacebar pauses both</li>
            </ul>
        </div>
    </div>

    <div id="main-area">
        <div id="canvas-container">
            <div class="canvas-wrap" id="wrap-left">
                <div class="canvas-label">Dragon Curve</div>
                <canvas id="canvas-left"></canvas>
                <div class="hud" id="hud-left">
                    Iter: <span id="iterL">0</span> | Angle: <span id="angleL">90°</span> | Sparkles: <span id="sparkleL">OFF</span>
                </div>
            </div>
            <div class="canvas-wrap" id="wrap-right">
                <div class="canvas-label">Spiral</div>
                <canvas id="canvas-right"></canvas>
                <div class="hud" id="hud-right">
                    Iter: <span id="iterR">0</span> | Angle: <span id="angleR">91°</span> | Sparkles: <span id="sparkleR">OFF</span>
                </div>
            </div>
        </div>
        <div id="info-bar">Click & drag to draw · Every 2nd click toggles sparkles · Shift+Click adds walker · Scroll adjusts angle · Space pauses</div>
    </div>

    <script>
        // Sparkle class
        class Sparkle {
            constructor(x, y, ctx) {
                this.x = x;
                this.y = y;
                this.ctx = ctx;
                this.size = Math.random() * 3 + 1;
                this.life = 1.0;
                this.decay = Math.random() * 0.02 + 0.01;
                this.twinkle = Math.random() * Math.PI * 2;
                this.twinkleSpeed = Math.random() * 0.3 + 0.1;
            }

            update() {
                this.life -= this.decay;
                this.twinkle += this.twinkleSpeed;
            }

            draw() {
                const alpha = this.life * (0.5 + 0.5 * Math.sin(this.twinkle));
                const size = this.size * (0.5 + 0.5 * Math.sin(this.twinkle * 2));
                const ctx = this.ctx;

                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = '#ffccdd';
                ctx.shadowBlur = 6;

                ctx.beginPath();
                for (let i = 0; i < 4; i++) {
                    const angle = (i * Math.PI / 2) + this.twinkle * 0.5;
                    const outerX = this.x + Math.cos(angle) * size * 2;
                    const outerY = this.y + Math.sin(angle) * size * 2;
                    const innerAngle = angle + Math.PI / 4;
                    const innerX = this.x + Math.cos(innerAngle) * size * 0.5;
                    const innerY = this.y + Math.sin(innerAngle) * size * 0.5;

                    if (i === 0) ctx.moveTo(outerX, outerY);
                    else ctx.lineTo(outerX, outerY);
                    ctx.lineTo(innerX, innerY);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        // Walker class
        class Walker {
            constructor(x, y, sim, startAngle = 0, startHue = Math.random() * 360) {
                this.x = x;
                this.y = y;
                this.sim = sim;
                this.angle = startAngle;
                this.hue = startHue;
                this.iteration = 0;
            }

            step() {
                const { ctx, params, W, H, sparkleMode, sparkles } = this.sim;
                const rad = (this.angle * Math.PI) / 180;
                const newX = this.x + Math.cos(rad) * params.stepLength;
                const newY = this.y + Math.sin(rad) * params.stepLength;

                const pinkHue = 340 + Math.sin(this.hue * 0.05) * 10;
                ctx.strokeStyle = `hsl(${pinkHue}, ${params.saturation}%, ${params.lightness}%)`;
                ctx.lineWidth = params.lineWidth;
                ctx.lineCap = 'round';

                if (params.glow) {
                    ctx.shadowColor = `hsl(${pinkHue}, ${params.saturation}%, ${params.lightness}%)`;
                    ctx.shadowBlur = 4;
                } else {
                    ctx.shadowBlur = 0;
                }

                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(newX, newY);
                ctx.stroke();
                ctx.shadowBlur = 0;

                if (sparkleMode && Math.random() < 0.3) {
                    const t = Math.random();
                    const sx = this.x + (newX - this.x) * t;
                    const sy = this.y + (newY - this.y) * t;
                    sparkles.push(new Sparkle(sx, sy, ctx));
                }

                this.x = newX;
                this.y = newY;

                let n = this.iteration;
                while (n > 0 && (n & 1) === 0) n >>= 1;
                if (n & 1) this.angle += params.turnAngle;
                else this.angle -= params.turnAngle;

                this.angle = ((this.angle % 360) + 360) % 360;
                this.hue = (this.hue + params.hueShift) % 360;
                this.iteration++;

                if (params.wrap) {
                    if (this.x < 0) this.x += W;
                    if (this.x > W) this.x -= W;
                    if (this.y < 0) this.y += H;
                    if (this.y > H) this.y -= H;
                }
            }
        }

        // Simulation class
        class Simulation {
            constructor(canvasId, wrapId, name, preset) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.wrap = document.getElementById(wrapId);
                this.name = name;
                this.W = 0;
                this.H = 0;
                this.walkers = [];
                this.sparkles = [];
                this.sparkleMode = false;
                this.clickCount = 0;

                this.params = {
                    turnAngle: preset.angle,
                    stepLength: preset.step,
                    lineWidth: preset.width,
                    speed: preset.speed,
                    hueShift: preset.hue,
                    saturation: preset.sat,
                    lightness: preset.light,
                    glow: false,
                    wrap: true,
                    bgColor: '#ffffff'
                };

                this.isDragging = false;
                this.lastDragX = 0;
                this.lastDragY = 0;
                this.drawHue = 0;

                this.setupInteraction();
            }

            resize() {
                this.W = this.wrap.clientWidth;
                this.H = this.wrap.clientHeight;
                this.canvas.width = this.W;
                this.canvas.height = this.H;
                this.clear();
            }

            clear() {
                this.ctx.fillStyle = this.params.bgColor;
                this.ctx.fillRect(0, 0, this.W, this.H);
            }

            init() {
                this.walkers = [new Walker(this.W / 2, this.H / 2, this, 0, 200)];
                this.sparkles = [];
                this.clear();
            }

            setupInteraction() {
                this.canvas.addEventListener('mousedown', e => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;

                    this.clickCount++;
                    if (this.clickCount % 2 === 0) {
                        this.sparkleMode = !this.sparkleMode;
                    }

                    if (e.shiftKey) {
                        this.walkers.push(new Walker(mx, my, this, Math.random() * 360, Math.random() * 360));
                    } else {
                        // Start dragging for freehand drawing
                        this.isDragging = true;
                        this.lastDragX = mx;
                        this.lastDragY = my;

                        // Also set origin for walker
                        if (this.walkers.length > 0) {
                            this.walkers[0].x = mx;
                            this.walkers[0].y = my;
                            this.walkers[0].iteration = 0;
                        }
                    }
                });

                this.canvas.addEventListener('mousemove', e => {
                    if (!this.isDragging) return;
                    const rect = this.canvas.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;

                    // Draw line from last position to current
                    const pinkHue = 340 + Math.sin(this.drawHue * 0.05) * 10;
                    this.ctx.strokeStyle = `hsl(${pinkHue}, ${this.params.saturation}%, ${this.params.lightness}%)`;
                    this.ctx.lineWidth = this.params.lineWidth;
                    this.ctx.lineCap = 'round';

                    if (this.params.glow) {
                        this.ctx.shadowColor = this.ctx.strokeStyle;
                        this.ctx.shadowBlur = 4;
                    }

                    this.ctx.beginPath();
                    this.ctx.moveTo(this.lastDragX, this.lastDragY);
                    this.ctx.lineTo(mx, my);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;

                    // Spawn sparkles while drawing if sparkle mode is on
                    if (this.sparkleMode && Math.random() < 0.5) {
                        const t = Math.random();
                        const sx = this.lastDragX + (mx - this.lastDragX) * t;
                        const sy = this.lastDragY + (my - this.lastDragY) * t;
                        this.sparkles.push(new Sparkle(sx, sy, this.ctx));
                    }

                    this.lastDragX = mx;
                    this.lastDragY = my;
                    this.drawHue = (this.drawHue + this.params.hueShift * 3) % 360;

                    // Update walker position to follow drawing
                    if (this.walkers.length > 0) {
                        this.walkers[0].x = mx;
                        this.walkers[0].y = my;
                    }
                });

                this.canvas.addEventListener('mouseup', () => { this.isDragging = false; });
                this.canvas.addEventListener('mouseleave', () => { this.isDragging = false; });

                this.canvas.addEventListener('wheel', e => {
                    e.preventDefault();
                    const delta = e.deltaY < 0 ? 1 : -1;
                    this.params.turnAngle = Math.max(1, Math.min(180, this.params.turnAngle + delta));
                    if (this === activeSim) updateSliders();
                });
            }

            step() {
                for (let i = 0; i < this.params.speed; i++) {
                    this.walkers.forEach(w => w.step());
                }

                this.sparkles.forEach(s => { s.update(); s.draw(); });
                this.sparkles = this.sparkles.filter(s => s.life > 0);
                if (this.sparkles.length > 300) this.sparkles = this.sparkles.slice(-300);
            }

            applyPreset(preset) {
                this.params.turnAngle = preset.angle;
                this.params.stepLength = preset.step;
                this.params.lineWidth = preset.width;
                this.params.speed = preset.speed;
                this.params.hueShift = preset.hue;
                this.params.saturation = preset.sat;
                this.params.lightness = preset.light;
                this.init();
            }
        }

        // Presets
        const presets = {
            dragon: { angle: 90, step: 8, width: 1.5, speed: 15, hue: 0.8, sat: 70, light: 60 },
            spiral: { angle: 91, step: 6, width: 1, speed: 20, hue: 1.5, sat: 80, light: 55 },
            hex: { angle: 60, step: 10, width: 2, speed: 12, hue: 0.5, sat: 65, light: 60 },
            triangle: { angle: 120, step: 12, width: 1.5, speed: 10, hue: 0.3, sat: 75, light: 55 },
            chaos: { angle: 137, step: 5, width: 0.5, speed: 50, hue: 2, sat: 60, light: 65 },
            fine: { angle: 89, step: 3, width: 0.5, speed: 80, hue: 0.2, sat: 50, light: 70 }
        };

        // Create simulations
        const simLeft = new Simulation('canvas-left', 'wrap-left', 'Dragon', presets.dragon);
        const simRight = new Simulation('canvas-right', 'wrap-right', 'Spiral', presets.spiral);
        let activeSim = simLeft;
        let paused = false;
        let lastHudUpdate = 0;

        // Sim selector
        document.getElementById('selectLeft').addEventListener('click', () => {
            activeSim = simLeft;
            document.getElementById('selectLeft').classList.add('selected');
            document.getElementById('selectRight').classList.remove('selected');
            updateSliders();
        });
        document.getElementById('selectRight').addEventListener('click', () => {
            activeSim = simRight;
            document.getElementById('selectRight').classList.add('selected');
            document.getElementById('selectLeft').classList.remove('selected');
            updateSliders();
        });

        // Update sliders to match active sim
        function updateSliders() {
            const p = activeSim.params;
            document.getElementById('angle').value = p.turnAngle;
            document.getElementById('angleVal').textContent = p.turnAngle + '°';
            document.getElementById('step').value = p.stepLength;
            document.getElementById('stepVal').textContent = p.stepLength;
            document.getElementById('lineWidth').value = p.lineWidth;
            document.getElementById('widthVal').textContent = p.lineWidth.toFixed(1);
            document.getElementById('speed').value = p.speed;
            document.getElementById('speedVal').textContent = p.speed;
            document.getElementById('hue').value = p.hueShift;
            document.getElementById('hueVal').textContent = p.hueShift.toFixed(1);
            document.getElementById('sat').value = p.saturation;
            document.getElementById('satVal').textContent = p.saturation + '%';
            document.getElementById('light').value = p.lightness;
            document.getElementById('lightVal').textContent = p.lightness + '%';
            document.getElementById('glowCheck').checked = p.glow;
            document.getElementById('wrapCheck').checked = p.wrap;
        }

        // Wire sliders
        function wireSlider(id, key, displayId, suffix = '', isFloat = false) {
            const slider = document.getElementById(id);
            const display = document.getElementById(displayId);
            slider.addEventListener('input', () => {
                activeSim.params[key] = isFloat ? parseFloat(slider.value) : parseInt(slider.value);
                display.textContent = (isFloat ? activeSim.params[key].toFixed(1) : activeSim.params[key]) + suffix;
            });
        }

        wireSlider('angle', 'turnAngle', 'angleVal', '°');
        wireSlider('step', 'stepLength', 'stepVal');
        wireSlider('lineWidth', 'lineWidth', 'widthVal', '', true);
        wireSlider('speed', 'speed', 'speedVal');
        wireSlider('hue', 'hueShift', 'hueVal', '', true);
        wireSlider('sat', 'saturation', 'satVal', '%');
        wireSlider('light', 'lightness', 'lightVal', '%');

        // Checkboxes
        document.getElementById('glowCheck').addEventListener('change', e => { activeSim.params.glow = e.target.checked; });
        document.getElementById('wrapCheck').addEventListener('change', e => { activeSim.params.wrap = e.target.checked; });

        // Presets
        document.getElementById('presetDragon').addEventListener('click', () => { activeSim.applyPreset(presets.dragon); updateSliders(); });
        document.getElementById('presetSpiral').addEventListener('click', () => { activeSim.applyPreset(presets.spiral); updateSliders(); });
        document.getElementById('presetHex').addEventListener('click', () => { activeSim.applyPreset(presets.hex); updateSliders(); });
        document.getElementById('presetTriangle').addEventListener('click', () => { activeSim.applyPreset(presets.triangle); updateSliders(); });
        document.getElementById('presetChaos').addEventListener('click', () => { activeSim.applyPreset(presets.chaos); updateSliders(); });
        document.getElementById('presetFine').addEventListener('click', () => { activeSim.applyPreset(presets.fine); updateSliders(); });

        // Controls
        document.getElementById('pauseBtn').addEventListener('click', function() {
            paused = !paused;
            this.textContent = paused ? 'Resume All' : 'Pause All';
            this.classList.toggle('active', paused);
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            simLeft.init();
            simRight.init();
        });

        // Keyboard
        document.addEventListener('keydown', e => {
            if (e.code === 'Space') {
                e.preventDefault();
                paused = !paused;
                document.getElementById('pauseBtn').textContent = paused ? 'Resume All' : 'Pause All';
                document.getElementById('pauseBtn').classList.toggle('active', paused);
            } else if (e.code === 'KeyR') {
                simLeft.init();
                simRight.init();
            }
        });

        // Resize
        function resize() {
            simLeft.resize();
            simRight.resize();
            simLeft.init();
            simRight.init();
        }

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            if (!paused) {
                simLeft.step();
                simRight.step();
            } else {
                // Still draw sparkles when paused
                [simLeft, simRight].forEach(sim => {
                    sim.sparkles.forEach(s => { s.update(); s.draw(); });
                    sim.sparkles = sim.sparkles.filter(s => s.life > 0);
                });
            }

            // Update HUDs
            const now = performance.now();
            if (now - lastHudUpdate > 200) {
                lastHudUpdate = now;
                if (simLeft.walkers.length > 0) {
                    document.getElementById('iterL').textContent = simLeft.walkers[0].iteration.toLocaleString();
                    document.getElementById('angleL').textContent = simLeft.params.turnAngle + '°';
                    document.getElementById('sparkleL').textContent = simLeft.sparkleMode ? 'ON ✨' : 'OFF';
                }
                if (simRight.walkers.length > 0) {
                    document.getElementById('iterR').textContent = simRight.walkers[0].iteration.toLocaleString();
                    document.getElementById('angleR').textContent = simRight.params.turnAngle + '°';
                    document.getElementById('sparkleR').textContent = simRight.sparkleMode ? 'ON ✨' : 'OFF';
                }
            }
        }

        // Init
        window.addEventListener('resize', resize);
        resize();
        updateSliders();
        animate();
    </script>
</body>
</html>
